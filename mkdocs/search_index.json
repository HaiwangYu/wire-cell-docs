{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Wire Cell\n\n\n\n\nThis is the \"production\" version of Wire Cell.  It is a work in\nprogress meant to provide long term sustainable development on a\nvariety of computing architectures (uniproc, multiproc, HPC, GPU).\nThe concepts of the Wire Cell method are being developed in the\nworking prototype version.  See the\n\nWire Cell home page\n for more\ndetails.", 
            "title": "Overview"
        }, 
        {
            "location": "/#welcome-to-wire-cell", 
            "text": "This is the \"production\" version of Wire Cell.  It is a work in\nprogress meant to provide long term sustainable development on a\nvariety of computing architectures (uniproc, multiproc, HPC, GPU).\nThe concepts of the Wire Cell method are being developed in the\nworking prototype version.  See the Wire Cell home page  for more\ndetails.", 
            "title": "Welcome to Wire Cell"
        }, 
        {
            "location": "/install/install/", 
            "text": "Dependencies in Wire Cell\n\n\nWire Cell software suite is composed of multiple packages with a\ncarefully considered on themselves and on external packages.  Wire\nCell software is designed in layers to provide as much or as little\nfunctionality as needed.  The more layer, the more dependencies.  The\ncore part of Wire Cell has minimal dependencies:\n\n\n\n\nC++11/14 compiler (GCC most tested)\n\n\nBOOST (1.59 if pipeline is used)\n\n\n\n\nWire Cell packages have many unit tests and they tend to also required\nROOT and some Wire Cell shared libraries explicitly require root (eg,\nRio and RootDict).\n\n\n\n\nROOT 6\n\n\n\n\nFIXME: we will eventually likely require:\n\n\n\n\nEigen3\n\n\nBoost.Pipeline\n\n\n\n\nAnd maybe others.\n\n\nGetting Wire Cell source package\n\n\nWire Cell source code is available from the\n\nWire Cell GitHub organization\n.\n\n\nThe recommended access is via Wire Cell developer SSH keys:\n\n\n$ git clone git@github.com:WireCell/wire-cell-build.git\n$ cd wire-cell-build/\n$ git submodule init\n$ git submodule update\n\n\n\n\nIf you are anonymous then you may instead clone through HTTPS and\nswitch git URLs before running \ngit submodule\n:\n\n\n$ git clone https://github.com/WireCell/wire-cell-build.git\n$ cd wire-cell-build/\n$ ./switch-git-urls\n\n\n\n\nBuilding wire-cell\n\n\nWire Cell software is built with \nwaf\n.  A custom Waf\ncommand (\nwcb\n = \"wire cell builder\") is provided:\n\n\nTo configure, build and install the wire cell code do:\n\n\n$ ./wcb --prefix=/path/to/install configure build install\n\n\n\n\nIf dependencies are not found you may specify them with additional\nflags as shown by the help.  Eg:\n\n\n$ ./wcb --help\n$ ./wcb --boost-libs=... --boost-includes=... --with-root=... configure\n$ ./wcb\n$ ./wcb install\n\n\n\n\nRun-time environment\n\n\nIt is assumed you have already set up your run-time environment so\nthat you can access the external dependencies in the \"usual manner\".\nFor wire-cell itself you will need to further set or add to the usual\nenvironment variables:\n\n\n\n\nPATH\n\n\nLD_LIBRARY_PATH\n\n\nPYTHONPATH\n\n\n\n\nto point to directories under the \n/path/to/install\n you used with \nwcb configure\n.\n\n\nPlatform notes:\n\n\n\n\nUbuntu:\n :: Set \nPYTHONNOUSERSITE\n to \nyes\n (or anything) if you also have Ubuntu ROOT packages installed.  This will stop the system PyROOT from being picked up\n\n\nScientific Linux:\n :: the build currently installs to both \nlib/\n and \nlib64/\n directories so add both to your \nLD_LIBRARY_PATH\n.", 
            "title": "Install Wire Cell"
        }, 
        {
            "location": "/install/install/#dependencies-in-wire-cell", 
            "text": "Wire Cell software suite is composed of multiple packages with a\ncarefully considered on themselves and on external packages.  Wire\nCell software is designed in layers to provide as much or as little\nfunctionality as needed.  The more layer, the more dependencies.  The\ncore part of Wire Cell has minimal dependencies:   C++11/14 compiler (GCC most tested)  BOOST (1.59 if pipeline is used)   Wire Cell packages have many unit tests and they tend to also required\nROOT and some Wire Cell shared libraries explicitly require root (eg,\nRio and RootDict).   ROOT 6   FIXME: we will eventually likely require:   Eigen3  Boost.Pipeline   And maybe others.", 
            "title": "Dependencies in Wire Cell"
        }, 
        {
            "location": "/install/install/#getting-wire-cell-source-package", 
            "text": "Wire Cell source code is available from the Wire Cell GitHub organization .  The recommended access is via Wire Cell developer SSH keys:  $ git clone git@github.com:WireCell/wire-cell-build.git\n$ cd wire-cell-build/\n$ git submodule init\n$ git submodule update  If you are anonymous then you may instead clone through HTTPS and\nswitch git URLs before running  git submodule :  $ git clone https://github.com/WireCell/wire-cell-build.git\n$ cd wire-cell-build/\n$ ./switch-git-urls", 
            "title": "Getting Wire Cell source package"
        }, 
        {
            "location": "/install/install/#building-wire-cell", 
            "text": "Wire Cell software is built with  waf .  A custom Waf\ncommand ( wcb  = \"wire cell builder\") is provided:  To configure, build and install the wire cell code do:  $ ./wcb --prefix=/path/to/install configure build install  If dependencies are not found you may specify them with additional\nflags as shown by the help.  Eg:  $ ./wcb --help\n$ ./wcb --boost-libs=... --boost-includes=... --with-root=... configure\n$ ./wcb\n$ ./wcb install", 
            "title": "Building wire-cell"
        }, 
        {
            "location": "/install/install/#run-time-environment", 
            "text": "It is assumed you have already set up your run-time environment so\nthat you can access the external dependencies in the \"usual manner\".\nFor wire-cell itself you will need to further set or add to the usual\nenvironment variables:   PATH  LD_LIBRARY_PATH  PYTHONPATH   to point to directories under the  /path/to/install  you used with  wcb configure .", 
            "title": "Run-time environment"
        }, 
        {
            "location": "/install/install/#platform-notes", 
            "text": "Ubuntu:  :: Set  PYTHONNOUSERSITE  to  yes  (or anything) if you also have Ubuntu ROOT packages installed.  This will stop the system PyROOT from being picked up  Scientific Linux:  :: the build currently installs to both  lib/  and  lib64/  directories so add both to your  LD_LIBRARY_PATH .", 
            "title": "Platform notes:"
        }, 
        {
            "location": "/install/external/", 
            "text": "External Packages\n\n\nThe \nwire-cell\n software in\n\nWire Cell GitHub\n depends on some\nsoftware that may not come with your OS, in particular\n\nROOT\n v6 and a compiler supports C++11/14.\n\n\nYou can provide the prerequisites as you wish or you can make use of the provided \nWorch\n-based automation to build the prerequisites from source.\n\n\nAutomated installation of externals with Worch\n\n\nThe Wire Cell software requires external packages of correct versions\nas described \nhere\n but does not require them to be installed\nin any particular manner.\n\n\nA \nWorch\n build orchestration\nconfiguration is provided which will allow automated installation of\nthe required externals.\n\n\nQuick start\n\n\nThe build may be as simple as:\n\n\n$ virtualenv /path/to/buildenv\n$ source /path/to/buildenv/bin/activate\n$ pip install worch\n\n$ git clone git@github.com:WireCell/wire-cell-externals.git /path/to/work\n$ cd /path/to/work\n$ waf --prefix=/path/to/install --orch-config=worch.cfg configure build\n$ deactivate\n\n$ source /path/to/install/env.sh\n$ module load root\n\n\n\n\nYou would repeat those last two lines in any new shells. You can now test:\n\n\n$ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05\n\n\n\n\nPreparing Worch\n\n\nMore details on the Worch automation and build options are described\nin the following sections.\n\n\nInstall Worch in Virtualenv\n\n\nIt is recommended to install the Worch build orchestration system into a Python virtual environment. This environment will be used only for building these externals.\n\n\n$ virtualenv /path/to/buildenv\n\n\n\n\nIf you system does not already provide it, \ndownload virtualenv\n and unpack it.  From the unpacked directory you can simply run\n\n\n$ python virtualenv.py /path/to/buildenv\n\n\n\n\nIn either case one activates the virtual environment and installs worch like:\n\n\n$ source /path/to/buildenv/bin/activate\n$ pip install worch\n\n\n\n\nInstall Worch in user dir\n\n\nOptionally, if you already have \npip\n available you may avoid using \nvirtualenv\n and install Worch into your \"user\" area under \n~/.local/\n:\n\n\n$ pip install --user worch\n\n\n\n\nYou will need to assure \n$HOME/.local/bin\n is in your \nPATH\n.\n\n\nWire-Cell Worch Configuration\n\n\nHowever you end up supplying Worch, the \nwire-cell-externals\n repository provides the rest of what is needed. Clone it to some place with ample disk space (10s of GB).\n\n\n$ git clone git@github.com:WireCell/wire-cell-externals.git /path/to/work\n$ cd /path/to/work\n$ waf --help\n\n\n\n\nBuild\n\n\nAfter the above is done, this one command builds all the external software:\n\n\n(1)  $ ls worch-*.cfg\n(2)  $ waf --prefix=/path/to/install --orch-config=worch-\nconfig\n.cfg configure\n(3)  $ waf\n(4)  $ deactivate\n\n\n\n\nThis does:\n\n\n\n\nSee which main configuration file is suited to your environment.\n\n\nConfigures the build according to the \nworch-\nconfig\n.cfg\n file and tells it where to install the final results.\n\n\nPerforms the automated build of external packages. This takes ~1 hour on Intel i7 w/ an SSD.\n\n\nExit the virtualenv as it is no longer needed (\n/path/to/buildenv\n may be removed)\n\n\n\n\nInstall\n\n\nThere are two ways to install the results of the build which differ in the organization of the installation directory layout. They are:\n\n\n\n\n\n\nname/version tree:\n Each package is installed into \n/path/to/install/\nname\n/\nversion\n/{bin,lib,include}\n. This allows for multiple versions of each package to be installed in parallel supporting different versions of an overall collection. It allows purging of a particular version by simply deleting the directory, although with care not to break other packages which depend on it. The user environment must be modified (\nPATH\n, etc) to pick up all run-time aspects of each individual package.\n\n\n\n\n\n\nsingle-rooted directory:\n All packages are installed in the same \n/path/to/install/{bin,lib,include}\n directory. User run-time environment still requires adjustment but only for a single aspect. Only one version of a package may be installed, and removing an installed package is not supported (but is possible).\nThis package supports both paradigms.\n\n\n\n\n\n\nThis package supports both paradigms.\n\n\nInstall to name/version tree\n\n\nBy default, and as part of the build procedure, one will produce a name/version tree installation area as designated by the \n--prefix\n option to \nwaf\n. The user run-time environment can be set up with the help of \nEnvironment Modules\n (EM) which are provided by the build.\n\n\n$ source /path/to/install/env.sh\n$ module load root\n\n$ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05\n\n\n\n\nSingle-rooted install\n\n\nIn addition to the population of \n/path/to/install\n as above, the build will produce a \"tarpack\" binary package file. These can simply be unpacked into a single-rooted directory.\n\n\n$ cd /path/to/work\n$ mkdir -p /path/to/single-rooted\n$ for n in tmp/tarpack/*.tgz; do tar -C /path/to/single-rooted -xf $n; done\n\n\n\n\nNo special environment setup mechanism is provided for this mechanism as one can largely piggy-back on the one ROOT provides:\n\n\n$ source /path/to/single-rooted/bin/thisroot.sh\n\n$ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05\n\n\n\n\nRACF Setup\n\n\nAt BNL's RACF, a simple, single-rooted installation of Wire Cell external packages is provided.\n\n\nBash users do:\n\n\n$ source /gpfs01/lbne/users/sw/wc/bin/thisroot.sh\n\n\n\n\nOr, if you are still stuck using \ntcsh\n do:\n\n\n source /gpfs01/lbne/users/sw/wc/bin/thisroot.csh", 
            "title": "Install Externals"
        }, 
        {
            "location": "/install/external/#external-packages", 
            "text": "The  wire-cell  software in Wire Cell GitHub  depends on some\nsoftware that may not come with your OS, in particular ROOT  v6 and a compiler supports C++11/14.  You can provide the prerequisites as you wish or you can make use of the provided  Worch -based automation to build the prerequisites from source.", 
            "title": "External Packages"
        }, 
        {
            "location": "/install/external/#automated-installation-of-externals-with-worch", 
            "text": "The Wire Cell software requires external packages of correct versions\nas described  here  but does not require them to be installed\nin any particular manner.  A  Worch  build orchestration\nconfiguration is provided which will allow automated installation of\nthe required externals.", 
            "title": "Automated installation of externals with Worch"
        }, 
        {
            "location": "/install/external/#quick-start", 
            "text": "The build may be as simple as:  $ virtualenv /path/to/buildenv\n$ source /path/to/buildenv/bin/activate\n$ pip install worch\n\n$ git clone git@github.com:WireCell/wire-cell-externals.git /path/to/work\n$ cd /path/to/work\n$ waf --prefix=/path/to/install --orch-config=worch.cfg configure build\n$ deactivate\n\n$ source /path/to/install/env.sh\n$ module load root  You would repeat those last two lines in any new shells. You can now test:  $ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05", 
            "title": "Quick start"
        }, 
        {
            "location": "/install/external/#preparing-worch", 
            "text": "More details on the Worch automation and build options are described\nin the following sections.  Install Worch in Virtualenv  It is recommended to install the Worch build orchestration system into a Python virtual environment. This environment will be used only for building these externals.  $ virtualenv /path/to/buildenv  If you system does not already provide it,  download virtualenv  and unpack it.  From the unpacked directory you can simply run  $ python virtualenv.py /path/to/buildenv  In either case one activates the virtual environment and installs worch like:  $ source /path/to/buildenv/bin/activate\n$ pip install worch  Install Worch in user dir  Optionally, if you already have  pip  available you may avoid using  virtualenv  and install Worch into your \"user\" area under  ~/.local/ :  $ pip install --user worch  You will need to assure  $HOME/.local/bin  is in your  PATH .  Wire-Cell Worch Configuration  However you end up supplying Worch, the  wire-cell-externals  repository provides the rest of what is needed. Clone it to some place with ample disk space (10s of GB).  $ git clone git@github.com:WireCell/wire-cell-externals.git /path/to/work\n$ cd /path/to/work\n$ waf --help", 
            "title": "Preparing Worch"
        }, 
        {
            "location": "/install/external/#build", 
            "text": "After the above is done, this one command builds all the external software:  (1)  $ ls worch-*.cfg\n(2)  $ waf --prefix=/path/to/install --orch-config=worch- config .cfg configure\n(3)  $ waf\n(4)  $ deactivate  This does:   See which main configuration file is suited to your environment.  Configures the build according to the  worch- config .cfg  file and tells it where to install the final results.  Performs the automated build of external packages. This takes ~1 hour on Intel i7 w/ an SSD.  Exit the virtualenv as it is no longer needed ( /path/to/buildenv  may be removed)", 
            "title": "Build"
        }, 
        {
            "location": "/install/external/#install", 
            "text": "There are two ways to install the results of the build which differ in the organization of the installation directory layout. They are:    name/version tree:  Each package is installed into  /path/to/install/ name / version /{bin,lib,include} . This allows for multiple versions of each package to be installed in parallel supporting different versions of an overall collection. It allows purging of a particular version by simply deleting the directory, although with care not to break other packages which depend on it. The user environment must be modified ( PATH , etc) to pick up all run-time aspects of each individual package.    single-rooted directory:  All packages are installed in the same  /path/to/install/{bin,lib,include}  directory. User run-time environment still requires adjustment but only for a single aspect. Only one version of a package may be installed, and removing an installed package is not supported (but is possible).\nThis package supports both paradigms.    This package supports both paradigms.  Install to name/version tree  By default, and as part of the build procedure, one will produce a name/version tree installation area as designated by the  --prefix  option to  waf . The user run-time environment can be set up with the help of  Environment Modules  (EM) which are provided by the build.  $ source /path/to/install/env.sh\n$ module load root\n\n$ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05  Single-rooted install  In addition to the population of  /path/to/install  as above, the build will produce a \"tarpack\" binary package file. These can simply be unpacked into a single-rooted directory.  $ cd /path/to/work\n$ mkdir -p /path/to/single-rooted\n$ for n in tmp/tarpack/*.tgz; do tar -C /path/to/single-rooted -xf $n; done  No special environment setup mechanism is provided for this mechanism as one can largely piggy-back on the one ROOT provides:  $ source /path/to/single-rooted/bin/thisroot.sh\n\n$ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05", 
            "title": "Install"
        }, 
        {
            "location": "/install/external/#racf-setup", 
            "text": "At BNL's RACF, a simple, single-rooted installation of Wire Cell external packages is provided.  Bash users do:  $ source /gpfs01/lbne/users/sw/wc/bin/thisroot.sh  Or, if you are still stuck using  tcsh  do:   source /gpfs01/lbne/users/sw/wc/bin/thisroot.csh", 
            "title": "RACF Setup"
        }, 
        {
            "location": "/dev/overview/", 
            "text": "Terms\n\n\nThese terms are used with specific meanings in Wire Cell\n\n\n\n\n\n\ncoordinate system\n\n: electrons drift in the negative-X direction toward the wire planes, Y points upward and is sometimes referred to as W, Z follows from the right-hand-rule.  U and V directions point at some angle w.r.t. W and are in the W-Z plane.\n\n\n\n\n\n\ntick\n\n: the unit of digitized time.\n\n\n\n\n\n\ntbin\n\n: one bin of time of some integral number of ticks\n\n\n\n\n\n\nwire plane\n\n: a two-dimensional extent in the Y-Z plane which is perpendicular to the drift direction.  There is a U, V and W (aka Y) wire plane which contains \nwire\n segments.  Each of these planes are slightly offset in the drift direction X.\n\n\n\n\n\n\ncharge\n\n: refers to an amount of charged particles drifting past the wire plane during one tick.  Sometimes used to refer to the deconvolved ADC in one tick which provides a measure of the charge.  Sometimes used to refer to the un-deconvolved signal.  Yes, it's confusing. \n\n\n\n\n\n\nwire\n\n: a segment or run of the conductor which senses the passing of drifting charge.  A wire runs in either the U, V or W (aka Y) direction.\n\n\n\n\n\n\nchannel\n\n: the unit of electronics responsible for digitizing charge on a wire.  For detectors with wrapped readout conductors a single channel maps to multiple wires.\n\n\n\n\n\n\ncell\n\n: a region of the plane surrounding an area near where three wires, one from each plane, are crossing (at least pairwise, if not in a triple-point).\n\n\n\n\n\n\ntiling\n\n: the set of cells which fully cover the plane with no gaps nor overlaps.  There is more than one way to tile the plane.\n\n\n\n\n\n\nblob\n\n: an association of continguous cells which is expected to contain a portion of the charge of the event from one tbin.  In general, the association will include cells which may not actually contain charge.  A blob is bounded by cells (or plane boundaries) which definitely do not contain charge.\n\n\n\n\n\n\nblob cluster\n\n: an association of a number of blobs, potentially from different tbins, which intend to capture an extended portion of charge that came from the passage of a single particle (track) or multiple, closely related particles (shower).\n\n\n\n\n\n\nslice\n\n: a qualifier to indicate information from one tbin.  A wire slice would indicate the collection of charge collected on wires at a given time.\n\n\n\n\n\n\nframe\n\n: the collection of slices readout as a continuous unit from the DAQ.", 
            "title": "Overview"
        }, 
        {
            "location": "/dev/dev/", 
            "text": "Developer activities\n\n\nThis section describes details of how to develop.\n\n\nBuild Dancing\n\n\nIt is useful to define an alias to the \nwcb\n command:\n\n\n$ cd wire-cell-build/\n$ alias wcb=`pwd`/wcb\n\n\n\n\nTo rebuild after hacking on the source just type:\n\n\n$ wcb\n\n\n\n\nWhen ready to install into the configured ``prefix'' installation area.  It is good to always do this as explicitly, by-hand running tests will link against libraries found in your environment which likely means where you are installing.\n\n\n$ wcb install\n\n\n\n\nTo force a full rebuild:\n\n\n$ wcb clean build\n\n\n\n\nTo blow away all build and configuration products:\n\n\n$ wcb distclean\n$ wcb --prefix=.... [...] configure\n\n\n\n\nTo limit building to just one submodule (and its dependencies):\n\n\n$ cd \nsubdir\n/\n$ wcb\n\n\n\n\nTo avoid running tests:\n\n\n$ wcb --notests install\n\n\n\n\nTo list build targets and build a specific one:\n\n\n$ wcb list\n$ wcb --target test_cpp\n\n\n\n\nDebug\n\n\nTo build for debugging one needs to reconfigure waf with a\n\n--build-debug=\nflags\n option and then the project must be cleaned\nand rebuilt. This can be done all at once like:\n\n\n$ wcb --prefix=/path/to/install --build-debug=-ggdb3 clean configure build install\n\n\n\n\nYou may also want to see what commands Waf is actually running to\nconfirm this option is transmitted, just add a \n-v\n to the command\nline:\n\n\n$ wcb -v\n\n\n\n\nFinally, run GDB in your usual, preferred manner:\n\n\n$ gdb --args /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource\n(gdb) run\n\n\n\n\nNew packages\n\n\nNew packages can be added to Wire Cell easily.\n\n\nViolating the dependency contracts among the existing packages is\nstrictly forbidden.\n\n\nConsiderations\n\n\nWire Cell packages are organized to be easy to create. It's much\nbetter to create many small packages and maybe later merge them than\nit is to split apart ones which have grown too monolithic. When\nthinking about writing some code consider\n\n\n\n\nWhat other packages will I need?\n\n\nWhat future packages will need mine?\n\n\n\n\nYou may have an idea for a package but in reality it is better split\nup into others. Here are reasons to believe your ideas fit into\nmultiple packages:\n\n\n\n\nWhen I describe my expected package functionality I use the word \"and\".\n\n\nSome other package should use part of my package but the other part is not needed.\n\n\n\n\nIf in doubt, make more, smaller packages (and talk to the devs).\n\n\nSource Package Conventions\n\n\nTo make them easy to build and aggregate they must follow a layout\nconvention.\n\n\nFirst, each source package must be kept in it's own git\nrepository. The recommended package naming convention is:\n\n\nwire-cell-NAME\n\n\n\n\nwhere \nNAME\n is some short identifier of the package's primary purpose.\n\n\nThe contents of the source package must be organized following these sub-directory conventions\n\n\nsrc/             # C++ source file for libraries with .cxx extensions or private headers\ninc/NAME/        # public/API C++ header files with .h extensions\ndict/LinkDef.h   # ROOT linkdef header (for rootcling dictionaries)\ntests/           # Unit tests Python (nosetests) files like test_*.py or main C++ programs named like test_*.cxx.\napps/            # main application(s), one appname.cxx file for each app named appname (todo: not yet supported)\npython/NAME      # python modules (todo: not yet supported)\nwscript_build    # a brief waf file\n\n\n\n\nThe \nwscript_build\n file specifies a name for the package which is\ngenerally the CamelCase version of the source package name.  It also\nspecifies a list Wire Cell and external package dependencies.\n\n\nFor example the \nwire-cell-iface\n source package build a\n\nWireCellIface\n binary package with a \nlibWireCellIface.so\n library\nheaders under \nWireCellIface/\n.  It depends on the \nwire-cell-util\n\nsource package which builds \nWireCellUtil\n.  Thus its \nwscript_build\n\nfile is:\n\n\nbld.simplpkg('WireCellIface', use='WireCellUtil')\n\n\n\n\nThis is Python and the \nbld\n object is a Waf build context. It is\nprovided automagically when waf interprets this file.\n\n\nBuild packages\n\n\nThe above is about \ncode packages\n. Code packages are built via a\n\nbuild package\n. This main build package, \nwire-cell-build\n is but one\npossible \"view\" into all the wire cell packages. Other build packages\nmay be created which only build some sub-set of all wire cell\npackages.\n\n\nTo add a new code package to a build package (such as this one) one\nmust do a quick little dance:\n\n\n$ mkdir \nname\n\n$ cd \nname\n/\n$ echo \nbld.smplpkg('WireCell\nName\n', use='WireCellUtil WireCellIface')\n \n wscript_build\n$ git init\n$ git commit -a -m \nStart code package \nname\n\n\n\n\n\nReplace \nname\n with your package name. And, of course, you may want\nto put more code than just the \nwscript_build\n file. Also, that file\nshould list what packages your package depends on.\n\n\nNow, make a new repository by going to the\n\nWireCell GitHub\n and clicking \"New\nrepository\" button. Give it a name like\n\nwire-cell-\nname\n. Copy-and-paste the two command it tells you to\nuse:\n\n\n$ git remote add origin git@github.com:WireCell/wire-cell-\nname\n.git\n$ git push -u origin master\n\n\n\n\nFinally, move aside the local repository and add it right back as a submodule:\n\n\n$ cd ..  # back to top\n$ mv \nname\n \nname\n.moved\n$ git submodule add -- git@github.com:WireCell/wire-cell-\nname\n.git \nname\n\n$ git submodule update\n$ git commit -a -m \nAdded \nname\n to top-level build package.\n\n$ git push\n\n\n\n\nWhew!  Not bad, and you only need to do this dance with brand new packages once.\n\n\nNamespaces\n\n\nThe namespace \nWireCell\n is used for all \"core\" wire cell code.  Code\nwhich is optional or for interfacing with external systems must not\nexist inside \nWireCell\n.  For example, the \"simple simulation tree\"\nuses \nWireCellSst\n.\n\n\nIt can be tedious to type explicit namespace qualifiers all the\ntime. You may use the directive\n\n\n// only in .cxx files!\nusing namespace WireCell;\n\n\n\n\nin order to avoid this typing.  However you may \nonly\n use this in\nimplementation files (\n*.cxx\n) and you may \nnever\n use it in\n(public) header files.\n\n\nDealing with git submodules\n\n\nFrom \nthe git book\n, do you updates like:\n\n\n$ git submodule update --remote --rebase\n\n\n\nor like\n\n\n$ git submodule update --remote --merge\n\n\n\nWith:\n\n\n\n\n\n\n--rebase\n:\n put our local commits on top of any new ones\n\n\n\n\n\n\n--merge\n:\n merge our commits into new ones\n\n\n\n\n\n\nThe first leaves a more \"linear\" commit history while the second leaves\n\"diamonds\" in the history whenever we have briefly diverged from the\nremote repository.  You can run \"\ngitk --all\n\" in wire-cell or one of the\nsubmodules to see what I mean.  Either way is fine.  Rebasing looks\ncleaner in the history but merge captures the subtle fact of where our\nline of development actually diverged.\n\n\nIn that link there are other interesting things to do:\n\n\n\n\n\n\nConfigure your repository so \"\ngit status\n\" in the top-level \"wire-cell\" gives us more info on the status of all submodules:\n\n\n$ git config status.submodulesummary 1\n\n\n\n\n\n\nMake it so \"\ngit diff\n\" in wire-cell will also show any diff's in the submodules:\n\n\n$ git config diff.submodule log\n\n\n\n\n\n\nTo check that we will push in the right order (submodules first):\n\n\n$ git push --recurse-submodules=check\n\n\n\n\n\n\nTo force submodules to push first\n\n\n$ git push --recurse-submodules=on-demand\n\n\n\n\n\n\nTo run any command in all submodules\n\n\n$ git submodule foreach 'the command'", 
            "title": "Building"
        }, 
        {
            "location": "/dev/dev/#developer-activities", 
            "text": "This section describes details of how to develop.", 
            "title": "Developer activities"
        }, 
        {
            "location": "/dev/dev/#build-dancing", 
            "text": "It is useful to define an alias to the  wcb  command:  $ cd wire-cell-build/\n$ alias wcb=`pwd`/wcb  To rebuild after hacking on the source just type:  $ wcb  When ready to install into the configured ``prefix'' installation area.  It is good to always do this as explicitly, by-hand running tests will link against libraries found in your environment which likely means where you are installing.  $ wcb install  To force a full rebuild:  $ wcb clean build  To blow away all build and configuration products:  $ wcb distclean\n$ wcb --prefix=.... [...] configure  To limit building to just one submodule (and its dependencies):  $ cd  subdir /\n$ wcb  To avoid running tests:  $ wcb --notests install  To list build targets and build a specific one:  $ wcb list\n$ wcb --target test_cpp", 
            "title": "Build Dancing"
        }, 
        {
            "location": "/dev/dev/#debug", 
            "text": "To build for debugging one needs to reconfigure waf with a --build-debug= flags  option and then the project must be cleaned\nand rebuilt. This can be done all at once like:  $ wcb --prefix=/path/to/install --build-debug=-ggdb3 clean configure build install  You may also want to see what commands Waf is actually running to\nconfirm this option is transmitted, just add a  -v  to the command\nline:  $ wcb -v  Finally, run GDB in your usual, preferred manner:  $ gdb --args /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource\n(gdb) run", 
            "title": "Debug"
        }, 
        {
            "location": "/dev/dev/#new-packages", 
            "text": "New packages can be added to Wire Cell easily.  Violating the dependency contracts among the existing packages is\nstrictly forbidden.", 
            "title": "New packages"
        }, 
        {
            "location": "/dev/dev/#considerations", 
            "text": "Wire Cell packages are organized to be easy to create. It's much\nbetter to create many small packages and maybe later merge them than\nit is to split apart ones which have grown too monolithic. When\nthinking about writing some code consider   What other packages will I need?  What future packages will need mine?   You may have an idea for a package but in reality it is better split\nup into others. Here are reasons to believe your ideas fit into\nmultiple packages:   When I describe my expected package functionality I use the word \"and\".  Some other package should use part of my package but the other part is not needed.   If in doubt, make more, smaller packages (and talk to the devs).", 
            "title": "Considerations"
        }, 
        {
            "location": "/dev/dev/#source-package-conventions", 
            "text": "To make them easy to build and aggregate they must follow a layout\nconvention.  First, each source package must be kept in it's own git\nrepository. The recommended package naming convention is:  wire-cell-NAME  where  NAME  is some short identifier of the package's primary purpose.  The contents of the source package must be organized following these sub-directory conventions  src/             # C++ source file for libraries with .cxx extensions or private headers\ninc/NAME/        # public/API C++ header files with .h extensions\ndict/LinkDef.h   # ROOT linkdef header (for rootcling dictionaries)\ntests/           # Unit tests Python (nosetests) files like test_*.py or main C++ programs named like test_*.cxx.\napps/            # main application(s), one appname.cxx file for each app named appname (todo: not yet supported)\npython/NAME      # python modules (todo: not yet supported)\nwscript_build    # a brief waf file  The  wscript_build  file specifies a name for the package which is\ngenerally the CamelCase version of the source package name.  It also\nspecifies a list Wire Cell and external package dependencies.  For example the  wire-cell-iface  source package build a WireCellIface  binary package with a  libWireCellIface.so  library\nheaders under  WireCellIface/ .  It depends on the  wire-cell-util \nsource package which builds  WireCellUtil .  Thus its  wscript_build \nfile is:  bld.simplpkg('WireCellIface', use='WireCellUtil')  This is Python and the  bld  object is a Waf build context. It is\nprovided automagically when waf interprets this file.", 
            "title": "Source Package Conventions"
        }, 
        {
            "location": "/dev/dev/#build-packages", 
            "text": "The above is about  code packages . Code packages are built via a build package . This main build package,  wire-cell-build  is but one\npossible \"view\" into all the wire cell packages. Other build packages\nmay be created which only build some sub-set of all wire cell\npackages.  To add a new code package to a build package (such as this one) one\nmust do a quick little dance:  $ mkdir  name \n$ cd  name /\n$ echo  bld.smplpkg('WireCell Name ', use='WireCellUtil WireCellIface')    wscript_build\n$ git init\n$ git commit -a -m  Start code package  name   Replace  name  with your package name. And, of course, you may want\nto put more code than just the  wscript_build  file. Also, that file\nshould list what packages your package depends on.  Now, make a new repository by going to the WireCell GitHub  and clicking \"New\nrepository\" button. Give it a name like wire-cell- name . Copy-and-paste the two command it tells you to\nuse:  $ git remote add origin git@github.com:WireCell/wire-cell- name .git\n$ git push -u origin master  Finally, move aside the local repository and add it right back as a submodule:  $ cd ..  # back to top\n$ mv  name   name .moved\n$ git submodule add -- git@github.com:WireCell/wire-cell- name .git  name \n$ git submodule update\n$ git commit -a -m  Added  name  to top-level build package. \n$ git push  Whew!  Not bad, and you only need to do this dance with brand new packages once.", 
            "title": "Build packages"
        }, 
        {
            "location": "/dev/dev/#namespaces", 
            "text": "The namespace  WireCell  is used for all \"core\" wire cell code.  Code\nwhich is optional or for interfacing with external systems must not\nexist inside  WireCell .  For example, the \"simple simulation tree\"\nuses  WireCellSst .  It can be tedious to type explicit namespace qualifiers all the\ntime. You may use the directive  // only in .cxx files!\nusing namespace WireCell;  in order to avoid this typing.  However you may  only  use this in\nimplementation files ( *.cxx ) and you may  never  use it in\n(public) header files.", 
            "title": "Namespaces"
        }, 
        {
            "location": "/dev/dev/#dealing-with-git-submodules", 
            "text": "From  the git book , do you updates like:  $ git submodule update --remote --rebase  or like  $ git submodule update --remote --merge  With:    --rebase :  put our local commits on top of any new ones    --merge :  merge our commits into new ones    The first leaves a more \"linear\" commit history while the second leaves\n\"diamonds\" in the history whenever we have briefly diverged from the\nremote repository.  You can run \" gitk --all \" in wire-cell or one of the\nsubmodules to see what I mean.  Either way is fine.  Rebasing looks\ncleaner in the history but merge captures the subtle fact of where our\nline of development actually diverged.  In that link there are other interesting things to do:    Configure your repository so \" git status \" in the top-level \"wire-cell\" gives us more info on the status of all submodules:  $ git config status.submodulesummary 1    Make it so \" git diff \" in wire-cell will also show any diff's in the submodules:  $ git config diff.submodule log    To check that we will push in the right order (submodules first):  $ git push --recurse-submodules=check    To force submodules to push first  $ git push --recurse-submodules=on-demand    To run any command in all submodules  $ git submodule foreach 'the command'", 
            "title": "Dealing with git submodules"
        }, 
        {
            "location": "/dev/iface/", 
            "text": "(FIXME: this needs rewriting.)\n\n\nOverview of Interfaces\n\n\nWire Cell has a number of high-level concepts which are implemented as\nC++ \"Interface\" classes.  Such classes expose only methods which take\nor return either Plain Old Data (POD) or instances from the\n\nWire Cell Data\n package.\n\n\nThe reason for this additional layer is to provide a decoupling\nbetween the different Wire Cell packages and to allow one to set\nactual implementations at the application layer.  This allows for\ncompeting implementations to be swapped in a transparent manner.  For\nexample, one may have a wire geometry that comes from a parameterized\nmodel that generates wire placements or one may have a detailed as-is\nsurvey where each wire is painstakingly described and stored.  The\ncode that uses such a geometry doesn't care and instead accesses\nwhatever the application layer gives it via the \nIWireGeometry\n\ninterface.\n\n\nA concrete implementation may present multiple interfaces.  For\nexample the \nGeomDataSource\n from the\n\nWire Cell Nav\n package\nprovides both \nIWireGeometry\n and \nIWireDatabase\n interfaces.\n\n\nProviding Interfaces\n\n\nInterface classes provide a mechanism to keep packages independent and\nloosely coupled.  It does this by having code depend only on the\ngeneric interface classes and not on the concrete implementations.  \n\n\nIt is possible (and easy) to violate paradigm and end up back with\ntightly coupled packages and code.  This unwanted tight coupling can\nstill occur if the code that produces the concrete implementation of\nan interface is intermixed with the code that consumes the interface.\n\n\nTo combat this one should layer the packages so that a higher\napplication layer is responsible for creating the concrete\nimplementations of interfaces as well as the consumer code (which may\nalso be accessed through interfaces).\n\n\nSpecifically, to maintain this separation one should place any\n\napps/*.cxx\n and \ntests/*.cxx\n main programs which create concrete\nimplementations of interfaces in a package other than the one that\nholds the generic \nsrc/*.cxx\n library files.\n\n\nContext\n\n\nThere are various important interfaces that most all of Wire Cell code\nwill require.  It is thus convenient to bundle access to these into a\nsingle interface called the \nIContext\n.  This simplifies high-level\napplication code as the code for creating and initializing a specific\ncontext can be provided as a high-level library.  For example, all\ngeometry and readout data may come from some domain.  One example is\nif the input to Wire Cell originates from\n\nWire Cell SST\n files.\nHigh-level application code can depend on SST, produce an SST-based\ncontext and feed its content to the Wire Cell code as generic\ninterfaces.\n\n\nExample\n\n\nThe figure below gives a hypothetical example.  At the top are the\nWire Cell interfaces.  In the middle are the concrete implementations\nof these interfaces.  At the very bottom are (paradoxically)\nhigh-level application components which aggregate concrete\nimplementations together in order to drive the program.  Shown is an\nexample of how Wire Cell and LArSoft might integrate.  A\n\nwire-cell-larsoft\n component would provide concrete implementations\nof Wire Cell interfaces using code that depends on facilities from\nLArSoft.  A high-level (at the bottom) \"application\" (an Art module)\nwould tie together the interfaces implemented by LArSoft code and the\nWire Cell implementation in order to run in an Art job.", 
            "title": "Interfaces"
        }, 
        {
            "location": "/dev/iface/#overview-of-interfaces", 
            "text": "Wire Cell has a number of high-level concepts which are implemented as\nC++ \"Interface\" classes.  Such classes expose only methods which take\nor return either Plain Old Data (POD) or instances from the Wire Cell Data  package.  The reason for this additional layer is to provide a decoupling\nbetween the different Wire Cell packages and to allow one to set\nactual implementations at the application layer.  This allows for\ncompeting implementations to be swapped in a transparent manner.  For\nexample, one may have a wire geometry that comes from a parameterized\nmodel that generates wire placements or one may have a detailed as-is\nsurvey where each wire is painstakingly described and stored.  The\ncode that uses such a geometry doesn't care and instead accesses\nwhatever the application layer gives it via the  IWireGeometry \ninterface.  A concrete implementation may present multiple interfaces.  For\nexample the  GeomDataSource  from the Wire Cell Nav  package\nprovides both  IWireGeometry  and  IWireDatabase  interfaces.", 
            "title": "Overview of Interfaces"
        }, 
        {
            "location": "/dev/iface/#providing-interfaces", 
            "text": "Interface classes provide a mechanism to keep packages independent and\nloosely coupled.  It does this by having code depend only on the\ngeneric interface classes and not on the concrete implementations.    It is possible (and easy) to violate paradigm and end up back with\ntightly coupled packages and code.  This unwanted tight coupling can\nstill occur if the code that produces the concrete implementation of\nan interface is intermixed with the code that consumes the interface.  To combat this one should layer the packages so that a higher\napplication layer is responsible for creating the concrete\nimplementations of interfaces as well as the consumer code (which may\nalso be accessed through interfaces).  Specifically, to maintain this separation one should place any apps/*.cxx  and  tests/*.cxx  main programs which create concrete\nimplementations of interfaces in a package other than the one that\nholds the generic  src/*.cxx  library files.", 
            "title": "Providing Interfaces"
        }, 
        {
            "location": "/dev/iface/#context", 
            "text": "There are various important interfaces that most all of Wire Cell code\nwill require.  It is thus convenient to bundle access to these into a\nsingle interface called the  IContext .  This simplifies high-level\napplication code as the code for creating and initializing a specific\ncontext can be provided as a high-level library.  For example, all\ngeometry and readout data may come from some domain.  One example is\nif the input to Wire Cell originates from Wire Cell SST  files.\nHigh-level application code can depend on SST, produce an SST-based\ncontext and feed its content to the Wire Cell code as generic\ninterfaces.", 
            "title": "Context"
        }, 
        {
            "location": "/dev/iface/#example", 
            "text": "The figure below gives a hypothetical example.  At the top are the\nWire Cell interfaces.  In the middle are the concrete implementations\nof these interfaces.  At the very bottom are (paradoxically)\nhigh-level application components which aggregate concrete\nimplementations together in order to drive the program.  Shown is an\nexample of how Wire Cell and LArSoft might integrate.  A wire-cell-larsoft  component would provide concrete implementations\nof Wire Cell interfaces using code that depends on facilities from\nLArSoft.  A high-level (at the bottom) \"application\" (an Art module)\nwould tie together the interfaces implemented by LArSoft code and the\nWire Cell implementation in order to run in an Art job.", 
            "title": "Example"
        }, 
        {
            "location": "/dev/data/", 
            "text": "(FIXME: this needs rewriting.)\n\n\nWire Cell has a simple ROOT I/O persistency module.  \n\n\nSchema\n\n\nThe data is saved to several ROOT TFiles is shown in the following\nfigure.  Refer to the \nterms\n section for a nomenclature.\n\n\n\n\n([\nPNG\n], [\nPDF\n], [\nDOT\n] and [\nSVG\n])\n\n\nGeneralities\n\n\nTo store the data into a ROOT file we must take care of ownership and\nreferences explicitly.  In general this is handled by representing\nownership as an array of objects and references as an index into this\narray.\n\n\nThere are three trees: Geometry, Channel and Cell.\n\n\nGeometry\n\n\nThe geometry is saved into a tree with a single entry.  There are\nthree owning arrays, \nWireStore\n, \nPointStore\n and \nTilingStore\n\nowning:\n\n\n\n\n\n\nWire\n with associated channel ID number (referred to in the\nChannel data tree) and two end points\n\n\n\n\n\n\nPoint\n all 3d Points referred to by other objects.\n\n\n\n\n\n\nCell\n associates a Wire via it's index (\nwid\n) with a center\n  point and an (ordered) array of points that make up the corners of\n  the cell.\n\n\n\n\n\n\nChannel\n\n\nInformation about charge read out from all channels in a frame.  One\nentry in this branch spans an entire readout frame.\n\n\n\n\n\n\nChannelStore\n holds all channel data for the frame\n\n\n\n\n\n\nChannelSlice\n associates a time bin \ntbin\n that counts relative\nto the start of the frame with a collection of read out channel\ncharges.  A negative charge is undefined.\n\n\n\n\n\n\nChannelCharge\n associates a channel ID with a charge.\n\n\n\n\n\n\nCell\n\n\nThe Cell branch holds associations between charge and cells and groups\nof cells.  This branch may hold MC truth value or reconstruction.\n\n\n\n\n\n\nCellCharge\n associates a cell ID, which is an index into the\n  \nTilingStore\n with a charge.  A negative charge is undefined.\n\n\n\n\n\n\nBlob\n owns an array of \nCellCharge\n.  The \ntechnique\n is a user\n  defined string to label the origin of the blob (eg, \"simtruth\" or\n  maybe \"2dtoyreco\", etc).  The \ntbin\n counts the time bin from the\n  beginning of the frame, the \nqtot\n is some measure of the charge for\n  the blob as a whole (and may not necessarily be the sum of the\n  charge on the individual cells).  The \nquality\nis a\n  \ntechnique\n-specific measure of quality and finally the array of\n  cell charge.\n\n\n\n\n\n\nBlobCluster\n is a (non-owning) association of blobs.  This may be\n  used to collect blobs together within one time slice or may be used\n  to collect them together across multiple time slices such as to form\n  the blobs contributing to a track or a shower.  Blobs are referenced\n  by their index into the frame's \nBlobStore\n.  All available\n  \nBlobClusters\n are stored in the \nClusterStore", 
            "title": "Persistency"
        }, 
        {
            "location": "/dev/data/#schema", 
            "text": "The data is saved to several ROOT TFiles is shown in the following\nfigure.  Refer to the  terms  section for a nomenclature.   ([ PNG ], [ PDF ], [ DOT ] and [ SVG ])", 
            "title": "Schema"
        }, 
        {
            "location": "/dev/data/#generalities", 
            "text": "To store the data into a ROOT file we must take care of ownership and\nreferences explicitly.  In general this is handled by representing\nownership as an array of objects and references as an index into this\narray.  There are three trees: Geometry, Channel and Cell.", 
            "title": "Generalities"
        }, 
        {
            "location": "/dev/data/#geometry", 
            "text": "The geometry is saved into a tree with a single entry.  There are\nthree owning arrays,  WireStore ,  PointStore  and  TilingStore \nowning:    Wire  with associated channel ID number (referred to in the\nChannel data tree) and two end points    Point  all 3d Points referred to by other objects.    Cell  associates a Wire via it's index ( wid ) with a center\n  point and an (ordered) array of points that make up the corners of\n  the cell.", 
            "title": "Geometry"
        }, 
        {
            "location": "/dev/data/#channel", 
            "text": "Information about charge read out from all channels in a frame.  One\nentry in this branch spans an entire readout frame.    ChannelStore  holds all channel data for the frame    ChannelSlice  associates a time bin  tbin  that counts relative\nto the start of the frame with a collection of read out channel\ncharges.  A negative charge is undefined.    ChannelCharge  associates a channel ID with a charge.", 
            "title": "Channel"
        }, 
        {
            "location": "/dev/data/#cell", 
            "text": "The Cell branch holds associations between charge and cells and groups\nof cells.  This branch may hold MC truth value or reconstruction.    CellCharge  associates a cell ID, which is an index into the\n   TilingStore  with a charge.  A negative charge is undefined.    Blob  owns an array of  CellCharge .  The  technique  is a user\n  defined string to label the origin of the blob (eg, \"simtruth\" or\n  maybe \"2dtoyreco\", etc).  The  tbin  counts the time bin from the\n  beginning of the frame, the  qtot  is some measure of the charge for\n  the blob as a whole (and may not necessarily be the sum of the\n  charge on the individual cells).  The  quality is a\n   technique -specific measure of quality and finally the array of\n  cell charge.    BlobCluster  is a (non-owning) association of blobs.  This may be\n  used to collect blobs together within one time slice or may be used\n  to collect them together across multiple time slices such as to form\n  the blobs contributing to a track or a shower.  Blobs are referenced\n  by their index into the frame's  BlobStore .  All available\n   BlobClusters  are stored in the  ClusterStore", 
            "title": "Cell"
        }, 
        {
            "location": "/dev/test/", 
            "text": "(FIXME: this section needs work.)\n\n\nTests\n\n\nTests go under the \ntest/\n (or \ntests/\n) sub-directory of the package.  There are two types, C++ and Python.  In both cases, only files that begin with \"\ntest_*\n\" will be considered tests.  Tests are automatically run as part of the build procedure (fixme: just C++ ones are automatic right now) and will be rerun when they or code they depend on changes.   When tests are run by the build the \nstdout/stderr\n is typically captured.  You can run them manually to observe any print statements.  Tests are not installed but left in the \"\nbuild/\n\" (or sometimes \"\ntmp/\n\") output directory.\n\n\nHere are a few general guidelines for writing tests:\n\n\n\n\nwrite many tests\n\n\nwrite tests as fine grained as convenient\n\n\nthe best tests are written before or while the code they test is being written\n\n\ntest code does need not be \"pretty\", it will never be called from anywhere else\n\n\ntests should run quickly\n\n\ndo use contrived data or mocked code to provide a bit of test code it's needed input or code support\n\n\n\n\nC++ tests\n\n\nWriting a C++ test is to write a \nmain()\n program which takes \nno arguments\n.  If a test fails, either let it crash the test program or call \nexit(1)\n.\n\n\nYou can explicitly run C++ test programs.  When they are run as part of the build, their full path is printed.  When run automatically, waf takes care of setting up their environment so that their libraries are found.  When run manually you will have to assure this.  The simplest way is to \nwaf install\n\" the package first.\n\n\n$ waf\n...\nexecution summary\n  tests that pass 3/4\n    /home/bviren/projects/wire-cell/top/build/data/test_construct\n    /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource\n    /home/bviren/projects/wire-cell/top/build/sst/tgeomdatasource\n  tests that fail 1/4\n    /home/bviren/projects/wire-cell/top/build/data/test_fail\n'build' finished successfully\n\n$ waf install\n\n$ /home/bviren/projects/wire-cell/top/build/sst/test_sst_geomdatasource\nWire: 0 plane=1 index=0\nWire: 0 plane=1 index=1\nWire: 0 plane=1 index=2\n...", 
            "title": "Testing"
        }, 
        {
            "location": "/dev/test/#tests", 
            "text": "Tests go under the  test/  (or  tests/ ) sub-directory of the package.  There are two types, C++ and Python.  In both cases, only files that begin with \" test_* \" will be considered tests.  Tests are automatically run as part of the build procedure (fixme: just C++ ones are automatic right now) and will be rerun when they or code they depend on changes.   When tests are run by the build the  stdout/stderr  is typically captured.  You can run them manually to observe any print statements.  Tests are not installed but left in the \" build/ \" (or sometimes \" tmp/ \") output directory.  Here are a few general guidelines for writing tests:   write many tests  write tests as fine grained as convenient  the best tests are written before or while the code they test is being written  test code does need not be \"pretty\", it will never be called from anywhere else  tests should run quickly  do use contrived data or mocked code to provide a bit of test code it's needed input or code support", 
            "title": "Tests"
        }, 
        {
            "location": "/dev/test/#c-tests", 
            "text": "Writing a C++ test is to write a  main()  program which takes  no arguments .  If a test fails, either let it crash the test program or call  exit(1) .  You can explicitly run C++ test programs.  When they are run as part of the build, their full path is printed.  When run automatically, waf takes care of setting up their environment so that their libraries are found.  When run manually you will have to assure this.  The simplest way is to  waf install \" the package first.  $ waf\n...\nexecution summary\n  tests that pass 3/4\n    /home/bviren/projects/wire-cell/top/build/data/test_construct\n    /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource\n    /home/bviren/projects/wire-cell/top/build/sst/tgeomdatasource\n  tests that fail 1/4\n    /home/bviren/projects/wire-cell/top/build/data/test_fail\n'build' finished successfully\n\n$ waf install\n\n$ /home/bviren/projects/wire-cell/top/build/sst/test_sst_geomdatasource\nWire: 0 plane=1 index=0\nWire: 0 plane=1 index=1\nWire: 0 plane=1 index=2\n...", 
            "title": "C++ tests"
        }, 
        {
            "location": "/alg/cell/", 
            "text": "", 
            "title": "Making Cells"
        }, 
        {
            "location": "/alg/blob/", 
            "text": "", 
            "title": "Blob Reconstruction"
        }, 
        {
            "location": "/viz/webgl/", 
            "text": "", 
            "title": "WebGL"
        }, 
        {
            "location": "/meta/meta/", 
            "text": "About this site\n\n\nThis site uses MkDocs and is served by GitHub.\n\n\nTo edit\n\n\n$ git clone git@github.com:WireCell/wire-cell-docs.git\n$ cd wire-cell-docs\n$ emacs \n$ git commit -a -m \n...\n\n$ git push\n\n\n\n\nTo preview\n\n\n$ mkdocs server\nINFO    -  Building documentation... \n[I 150708 17:57:26 server:271] Serving on http://127.0.0.1:8000\n[I 150708 17:57:26 handlers:58] Start watching changes\n[I 150708 17:57:26 handlers:60] Start detecting changes\n\n\n\n\nClick on the link to view the result in your browser.  As you continue\nto edit the server should notice the change, regenerate and trigger\nyour browser to refresh.\n\n\nTo deploy\n\n\n$ mkdocs gh-deploy --clean\n\n\n\n\nAfter a brief moment this will update \nthe main docs site\n.", 
            "title": "About"
        }, 
        {
            "location": "/meta/meta/#about-this-site", 
            "text": "This site uses MkDocs and is served by GitHub.  To edit  $ git clone git@github.com:WireCell/wire-cell-docs.git\n$ cd wire-cell-docs\n$ emacs \n$ git commit -a -m  ... \n$ git push  To preview  $ mkdocs server\nINFO    -  Building documentation... \n[I 150708 17:57:26 server:271] Serving on http://127.0.0.1:8000\n[I 150708 17:57:26 handlers:58] Start watching changes\n[I 150708 17:57:26 handlers:60] Start detecting changes  Click on the link to view the result in your browser.  As you continue\nto edit the server should notice the change, regenerate and trigger\nyour browser to refresh.  To deploy  $ mkdocs gh-deploy --clean  After a brief moment this will update  the main docs site .", 
            "title": "About this site"
        }
    ]
}