#+title: Rays and their Grids, Tiling and Clustering
#+LATEX_HEADER: \usepackage{svg}

* Rays Basics

In WCT, in the ~WireCell~ namespace, a ~Ray~ is simply a ~std::pair<Point,Point>~ defined in ~wire-cell-util~ in the ~Point.h~ header.  Conceptually it represents an relative vector pointing *from* ~Ray::first~ and *to* ~Ray::second~.  Various vector operations are defined on ~Point~ and ~Ray~.  Note, one may see ~Vector~ used.  It is a synonym for ~Point~ and sometimes used to semantically distinguish between a relative displacement and an absolute point. 

Rays may be used in several contexts and one critical one is in describing geometry related to wires (as always, this means wire segments).  The rest of this section describes how rays are used to implement the core Wire-Cell imaging algorithms.  It covers a progression of functionality:

- grid :: construction of a set of grids defined in terms of rays which allow fast /addressing/ of special points in a 2D space
- tiling :: partitioning the 2D space, based on the grid, to constrain location of activity
- clustering :: combining elements of the 2D tiling along a third dimension

This functionality is based on bounding regions of the 2D plane with pairs of parallel rays.  A region is considered to have infinite extent along the mutual direction of its bounding rays and to have finite extent along the perpendicular direction.  This finite extent is represented by a *pitch* vector which has its end points on both rays.  The ray on the tail of the pitch vector is considered inside the region while the other ray is considered outside.   That is, the region is half-inclusive.  


* Ray Grid

The wire segments in a pair wire planes provide a basis for a non-orthogonal grid.  Under the assumption that the wires share a common pitch and angle the grid is uniform.  This assumption allows for optimization in calculating crossing ray crossing points in terms of indexed grid points.  It further allows optimization in calculating the location of a crossing point in terms of the pitch location of a third plane.  

A generalized /ray grid/ as consisting of a number of coplanar /layers/.  Each layer is composed of a infinite number of parallel rays of uniform pitch which may be generated by specifying an ordered pair of two neighboring rays.  The /pitch vector/ of this layer is generated as running perpendicular to both rays and of magnitude that of their separation.  A three-layer ray grid is illustrated in the following figure.


[[file:figs/test_raytiling-00.svg]]


A number of vectors are defined.  Their superscript indices label a layer and their subscripts label grid indices.

- $p^l$ :: the pitch vector for layer $l$
- $c^n$ :: a special center point on /ray 0/ of layer $n$
- $r^{lm}_{ij}$ :: the crossing point of ray $i$ from layer $l$ and ray $j$ from layer $m$
- $r^{lm}_{00}$ :: the crossing point the zero rays of layers $l$ and $m$.
- $w^{lm}$ :: a vector giving the displacement along the direction of a ray in layer $l$ between the crossing points of that ray and two neighboring rays from layer $m$

This last two tensors, $r^{lm}_{00}$ and $w^{lm}$ can be calculated with simple vector arithmetic (see ~ray_pitch()~ from ~Point.h~), pair-wise among the $N_l$ layers in the ray grid.  The former is symmetric and both have undefined diagonals and so require $\mathcal{O}(N_l^2)$ operations where $N_l$ is the number of layers (typically $N_l = 5$ as described below).  Given these two tensors, arbitrary crossing points of rays from different layers can be written as

\begin{equation}
r^{lm}_{ij} = r^{lm}_{00} + j w^{lm} + i w^{ml}
\end{equation}

which provides a faster calculation than the vector arithmetic required to find the crossing points of arbitrary rays.  

Locating crossing points of rays from two layers in a third layer is another fundamental operation.  Given that these crossing points are on the ray grid a tensor equation can be written:

\begin{equation}
p^{lmn}_{ij} = (r^{lm}_{ij} - c^n) \cdot \hat{p}^n$
\end{equation}
Expanding $r^{lm}_{ij}$, 

\begin{equation}
P^{lmn}_{ij} = r^{lm}_{00}\cdot \hat{p}^n + jw^{lm} \cdot \hat{p}^n + iw^{ml} \cdot \hat{p}^n - c^n \cdot \hat{p}^n
\end{equation}

Given the tensor symmetries, one can express more simply this as: $P^{lmn}_{ij} = ja^{lmn} + ia^{mln} + b^{lmn}$.  The tensors $a$ and $b$ are scalar valued, $a$ is not symmetric under a transpose of $l$ and $m$ and $b$ is.  Both have undefined diagonals.  That is, $l, m, n$ must be mutually unique.  Finally, it is common to look up some quantity that is indexed by the ray index.  This can be found simply a $I^{lmn}_{ij} = floor(P^{lmn}_{ij}/p^n)$.

* Ray Tiling

Central to Wire-Cell 3D imaging is the concept of "tiling".  This is a partitioning of the 2D plane that is transverse to the electron drift direction by considering the measured signal samples from all channels summed over some slice of time (typically a few ms).  The partitioning is performed along lines which are parallel to the wires of the planes on one face of an anode.

The goal of the tiling is to identify regions where ionized electrons likely existed in the time slice.  The procedure involves selecting all wires attached to all channels which collected signal (after response deconvolution) above some threshold.  These are called /active wires/.  The ray parallel to an active wire and residing half way along the negative pitch direction to the active wires nearest neighbor is called an /active ray/.  That is, an active ray provides the lower bounds of an  /active strip/ which is one pitch wide and centered along the active wire.

This is illustrated in the following figure.  It represents a simple simulation of a time slice.   Clumps of points are generated and for each point the nearest wire from each layer is located and its activity count is incremented.  



[[file:figs/test_raytiling-01.svg]]


The figure then shows a the active wire regions for five layers.  The first two layers are specially defined to provide the horizontal and vertical bounds of the detector.  These layers have a single gray colored strip with a pitch that spans their respective active area (100 units in the example).  

There are then three more layers of active strips colored red, green and blue and each which represents the active rays from one wire plane given the generated points represented as circles.  Wires which have no activity above threshold are seen as gaps between colored strips of any given layer.

The goal of tiling is thus to identify intersecting regions of all active strips through the layers. A contiguous region of intersection of strips from all layers is termed a /blob/.  Defining such blobs in terms of mutual intersecting of strips from many layers is inherently a combinatoric problem.  Given an initial pair of strips one has an outline of an initial blob.  A strip from a third layer is added and each corner point from the two-strip blob must be tested to determine if it is inside the new strip.  Likewise, all crossing points of the rays in the new strip and the rays in a particular strip in the prior blob must be identified and tested to determine if they are inside the other strip of the blob.  This must process must be iterated for every strip in every layer and extended for subsequent layers.

Exploiting the symmetry of uniform pitch and angle for each layer allows the optimized formula of the /ray grid/ to greatly reduce the cost of the computational primitives in this problem.  Calculating the pitch index $I^{lmn}_{ij}$ of layer $n$ for rays $i$ of layer $l$ and $j$ of $m$ allows immediate testing of points against an /activity vector/ which carries nonzero values for the rays associated with any active wires[fn:orgho].  The steps of tiling are illustrated in detail in the following subsection.


[fn:orgho] This latter optimization idea came from a Wire-Cell student at BNL, Orgho Anoronyo Neogi.



** Illustration of tiling

Tiling begins with the "Points and Activity" figure above.  While the generated points are drawn to help guide the eye, it's of course important to know that they are not consulted in the tiling.  They only provide the initial /strip activity/ arrays.  Contiguous regions of the activity array of each layer are found and define initial and compound strips.  All such initial strips are illustrated in the following figure.


[[file:figs/test_raytiling-02.svg]]

The first layers is immediately applied, forming one blob for every strip.  These 1-layer blobs have no corner points as they are bound only in a single pitch direction and extend infinitely in its perpendicular.  After the second layer is applied are the resulting 2-layer blobs have finite boundary.  The order of layer application is not mandatory but some optimization is gained by applying the special horizontal and vertical detector boundary layers first.  The result is illustrated in the following figure.

[[file:figs/test_raytiling-04.svg]]

Here, the vertical and horizontal boundary of a the active region of this (fictional) anode plane face is shown as a single square blob.  It can be seen that some point which were generated outside the detector active region will not be surrounded by any blob.  Next, the third layer is applied and it is the first actual wire plane.  It breaks up the single 2-layer blob into three.

[[file:figs/test_raytiling-05.svg]]

The fourth layer which is the second wire plane is applied to the 3-layer blob.  It is shown next.

[[file:figs/test_raytiling-06.svg]]

Given knowledge of the generated points, it is seen that some 4-layer blobs are now formed which do not surround any.  These are termed /ghost blobs/.  Processing techniques to remove these are described later.  For now they must be accepted.  However, adding the final layer shows that some portion of their area is excluded, while portions of the 4-layer blobs are split off and become ghosts.  The final layer:

[[file:figs/test_raytiling-07.svg]]

To help guide the eye, this final result overlayed with the original composite strips.

[[file:figs/test_raytiling-08.svg]]

* Blob Clustering

Blob cluster entails associating blobs found by tiling one time slice with those found by tiling a neighboring time slice.  The "association" based on determining if two blobs from their own time slice overlap when projected to the 2D plane.  Overlap is determined in terms of pitch measured in the layers of the blobs.  Within one pitch, overlap is determined if a number of corners of one blob are within the strip of the other blob.  The number of corners required and how far "within"  the other strip can in principle be parameterized.  For example, one may require two corners to be inside or no more than one pitch away from a strip boundary, or require that at least one corner is more than one pitch inside a strips boundary.  This choice has implications on the number of associations formed as a function of the angle of the ionization activity w.r.t. the 2D transverse plane.

One goal of blob clustering is to identify any blobs which do not form any associations and to remove them from further considerations.  This biases the blob sample to remove blobs which are "ghosts" or which contain very localized ionization activity.  Physics based studies are needed to understand this biasing.

Clustering blobs is very similar to their original formation via tiling.  In fact, one could extend the tiling algorithm to include layers from neighboring time slices.   However, this would lead to some redundant calculations and, worse, tighter coupling between algorithms.  Instead, blobs are formed independently in each time slice and then compared.

A naive algorithm to check overlap would require $\mathcal{O}(N^2_b)$ operations, where $N_b$ is the number of blobs in each time slice.  Given two blobs, an overlap can be determined in a worse case of $\mathcal{O}(N_cN_l)$ where $N_c$ is the number of corners in blobs and $N_l$ is their number of layers.  However, with a suitable representation, the same kind of optimization used for /ray grid/ can be exploited.

The main optimization which is added to what is already provided by the blob representation is to construct an index from a ray to a set of overlapping blobs (ray-blob-map).  This then allows fast traversal from blob to rays to blobs along one layer and those blobs can then be checked for overlap in the other layers.  The second optimization is to avoid a symmetric visit of blobs of both slice by employing the mark and sweep pattern.  In Python/pseudo code, the clustering algorithm is then:

#+BEGIN_EXAMPLE
for blob in slice[i]:

  other_blobs = slice[i+1];
  for strip in blob.strips:
    other_blobs = overlapping_blobs(other_blobs, strip)

  if other_blobs.empty():
    continue

  mark(blob)
  for other in other_blobs:
    mark(other)

#+END_EXAMPLE

Depending on the desired overlap policy, marks need not be applied to the ~slice[i+1]~ blobs or this algorithm may also be run on the preceding ~slice[i-1]~ blobs to produce markings of its blobs based on those of ~slice[i]~ which may not otherwise exist due to running the "forward" algorithm on ~slice[i-2]~.  Anytime outside of the desired scope of this inter-slice association, unmarked blobs may be swept out of future consideration. 

The key function is ~overlapping_blobs()~.  It determines which of its input blobs overlap the given strip in that strips layer.  It queries the ray-blob-map described above for each ray of $N_r$ in the strip and returns the set associated blobs.  While exhaustive, this is a (small) constant cost lookup in an array followed by a uniqueness test which may be based on a hash lookup.


* Comments, caveats and todo

This algorithm, as expected, clearly leaves "ghost" clusters as seen above.  These are clusters that do not actually contain any "electrons".  It is the job of subsequent stages to attempt to remove these.  

Finite numerical precision in specifying the ray pairs and calculating their crossing points can lead to slightly larger or smaller clusters.  These can be safely ignored.  However in the MicroBooNE wire pattern case in particular, a ray from each wire plane should exactly cross at a common point.  The lack of precision can thus cause minuscule but noticeable clusters to be formed *around* a triple crossing point. Such clusters are not physical.  Likely a selection based on cluster size can safely remove them.  Besides their small phase space being almost negligible, they form as ghost clusters in the tests that have been performed so far.  In any case, mitigation requires a little study.

Finally, these primitive operations, although central, are implemented as utility code.  To be useful in full scale operation, this code will largely be hidden from view inside WCT components which will handle constructing the coordinates from real wire geometry and filling activity arrays from slice data.

