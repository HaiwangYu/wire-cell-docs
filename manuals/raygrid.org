The ~RayGrid~ namespace holds some optimized calculations for things related to Wire-Cell's name.  

* Introduction

Central to Wire-Cell 3D imaging is the concept of "tiling".  This is a
partitioning of the 2D plane that is transverse to the electron drift
direction by considering the measured signal samples from all channels
summed over some slice of time.  The partitioning is performed along
lines which are parallel to the wires of the planes on one face of an
anode.

The goal of the tiling is to identify regions where ionized electrons
likely traveled.  This is done first by placing a threshold on signal
in each channel integrated over the time slice.  Any wire associated
with a channel with above threshold signal is considered "active".
Note, given planes with wrapped wires we can not yet know at this
point if a given segment is responsible for the signal or others
sharing the channel.  Thus if a channel is active then so are all its
wires.

The region of sensitivity assigned to each wire is called a (primitive) strip.  A strip is defined by the two *rays* on either side of and parallel to the wire which are located half way toward the wires nearest neighbors.  These two rays are thus separated along a line perpendicular to the wires by one *pitch*.

Conceptually, the tiling may then proceed by identifying all regions of the plane where the overlapping strips from all wires planes are active.  Or, conversely, identifying the region of the plane where at least one overlapping strip is not active.

To search the space an algorithm must perform certain primitive operations.  Two key operation is to locate a crossing point between two rays each associated with an active strip from their respective plane and determine if that point is inside an active strip of any other planes.  Note, the crossing point is physically the projection of the points of closest approach of two rays onto the 2D plane.  
This is illustrated in the following diagram (generated by ~test_rayclustering.cxx~ in ~wire-cell-util~).

[[file:figs/test_rayclustering-00.svg]]

Here, a trivial simulation is performed by randomly generating "electrons" in various clumps throughout the plane.  The colored bands represent active strips which contain at least one electron.  The goal of tiling is to draw convex hulls along the colored rays to surround the circles.  Or, in other words to locate regions with red, green blue and two shades of gray.

The primitive operation here is to calculate the crossing point of any two rays.  This is a simple calculation (linear vector equation) but it must be repeated for every pair of rays and the result must be compared to every ray of every active strip in all other planes to determine if the crossing point should be included.  Thus, this is potentially an $\mathcal{O}(N^3)$ operation where $N$ is the number of active strips in a plane.  Given this tiling must be repeated every time slice (typically chosen to be $2 \mu{}s$ of data and for each anode face (300 in DUNE), optimization is critical.

* Exploiting translational symmetry

WCT provides tiling classes and function in ~namespace RayGrid~ which are highly optimized for high speed and low memory usage.  Their optimization hinges on exploiting the assumption that all wires in a plane have uniform pitch and angle.  However, each plane may have a unique pitch (and of course a unique angle).  Furthermore, the number of planes is not limited.  In fact the horizontal and vertical bounds of the active area of the anode plane is modeled as one "wire" each which is always active.

The exploitation of translational symmetry allows for a frugal indexing mechanism to be constructed and queried.  This provides fast calculation of the ray crossings and if they are contained by a strip.  The former becomes an array lookup with a couple multiplies and additions and the latter becomes simply an array lookup[fn:orgho].

[fn:orgho] This latter optimization idea came from a Wire-Cell student at BNL, Orgho Anoronyo Neogi.

This indexing machinery is described.  First, a *ray* is physically defined in terms of its two endpoints and logically by an index $i$ which enumerates the rays in order as they span their plane.  The pair of rays $i={0,1}$ correspond to the "first" wire in the plane (ie, the wire that has a WCT wire-in-plane number of 0).  Negative ray indices are allowed (indices are ~int~) but may not be considered valid in all contexts.  

Next we define a ray *layer* which generalizes the wire plane.  It also includes the rays which define either the vertical or horizontal sensitive area of the overall anode face.  As stated, any number of layers may be included in the indexing.

Given the set of pairs of rays $i={0,1}$ from layer $l$ one can define an orthogonal coordinate system (see, eg WCT's ~Pimpos~ class for another).  This coordinate system defines an origin $\vec{c}^l$  at the center of ray $i=0$ and has its abscissa along the pitch direction $\hat{p}^l$.  The pitch magnitude defines a length scale along this first axis.  The ordinate is along the wire direction $\hat{w}^l$ which follows the convention that $\hat{x}\cdot\hat{w}^l = \hat{p}^l$ where $\hat{x}$ is the anti-drift direction (normal to the anode face).  Note, there is no particular length scale along $\hat{w}^l$.  

Next, given two such orthogonal coordinate systems and labeling rays from system $l$ with $i$ and those from system $m \ne l$ with $j$ one can construct a non-orthogonal 2D grid of ray crossing points in the form of a tensor $\vec{r}^{lm}_{ij}$.  Given such a grid we can recognize another tensor containing the relative vector $\vec{w}^{lm}$ which defines the displacement vector along a ray of $l$ and between the two crossing points of neighboring rays of $m$.  
That is, this tensor allows us to immediately "hop" to any given crossing point of ray $i$ of layer $l$ and ray $j$ of layer $m$ if the crossing point of the "zero rays" $\vec{r}^{lm}_{00}$ is known, $r^{lm}_{ij} = r^{lm}_{00} + j w^{lm} + i w^{ml}$. 
This reduces the geometric calculation of crossing points from $\mathcal{O}(N^2)$ where $N$ is the number of active strips per plane to $\mathcal{O}(n^2)$ where $n$ is the number of planes.

Finally, it was recognized that this formalism can be carried to the second critical primitive operation which is that of identifying if a crossing point is inside an active strip in yet another layer.  This has two parts: calculating the pitch location of the crossing point in the third layer's orthogonal coordinate system and then determining if that pitch is in an active strip.

For the first step, the pitch location in layer $n$ for a crossing or ray $i$ in layer $l$ and ray $j$ in layer $m$ is a tensor $P^{lmn}_{ij} = (r^{lm}_{ij} - c^n) \cdot \hat{p}^n$ where $c^n$ and $\hat{p}^n$ are defined as above.  Expanding one gets  $P^{lmn}_{ij} = r^{lm}_{00}\cdot \hat{p}^n + jw^{lm} \cdot \hat{p}^n + iw^{ml} \cdot \hat{p}^n - c^n \cdot \hat{p}^n$.  Given the tensor symmetries, one can express more simply this as: $P^{lmn}_{ij} = ja^{lmn} + ia^{mln} + b^{lmn}$.  The tensors $a$ and $b$ are now scalar valued, $a$ is not symmetric under a transpose of $l$ and $m$ and $b$ is.  Both have undefined diagonals.  That is, $l, m, n$ must be mutually unique.  

For each time slice and each layer, an activity array is prepared.  It assigns the amount of integrated signal above threshold in each channel to each of their associated wires in the layer.  This array is indexed by the wire-in-plane index, or equivalently by the lower bound ray associated with wire.  Thus, finally, the crossing point of ray $i$ from layer $l$ and ray $j$ from layer $m$ is within the strip of layer $n$ identified by the index
$I^{lmn}_ij} = floor(P^{lmn}_{ij}/p^n)$ where $p^n$ is the pitch magnitude of layer $n$.  This index can be applied to the activity array for layer $n$ to immediately determine if the crossing point should be considered to bound an active region in the tiling.

* Implementation

Building and querying the tensors described above is performed by the class ~RayGrid::Coordinates~.  To calculate the tensors it merely requires an ordered collection of ordered pairs of ${0,1}$ rays for the layers.  The index in this collection will later be used to refer to a layer.  By convention, layers 0 and 1 define a rectangular boundary of the sensitive area of the anode plane face.  Layers 2, 3 and 4 would then be the usual U, V and W planes.  Passing the rectangular boundary as the first two layers provides some further optimization to cut out large regions to check.

The tiling makes use of ~RayGrid::Coordinates~ and defines a number of additional classes. ~RayGrid::Strip~ defines a discrete region of pitch in a layer bounded by two rays.  Typically it spans multiple rays.  The ~RayGrid::Activity~ class holds the activity array for one layer.  It is "self shrinking" in that any rays with no activity are not stored.  However it always indices by absolute pitch index.  Finally, ~RayGrid::Cluster~ holds information about a number of (potentially) overlapping strips and their crossing points (called "corners").  A cluster is considered valid only if its strips have non-zero intersection and thus have non-empty set of corners.  The set of corners of a cluster is not in any particular order.  Building clusters is managed by the ~RayGrid::Clustering~ (verb) class which allows to seed a collection of (1 strip) clusters with an activity or to progressively apply more layers of activity to an existing collection of clusters.  This class relies on being given a ~RayGrid::Coordinates~ instance.  Finally, a bare function ~RayGrid::cluster()~ taking coordinates and a vector of activity wraps all that is required to fully build all possible clusters.

* Illustration of cluster building

Cluster building begins with the "Points and Activity" figure above.  Contiguous activity arrays of each plane are provided and their non-zero entries are illustrated as thin bars.  Strips are then built by finding contiguous regions of activity in each array.  This is illustrated in the following figure.

[[file:figs/test_rayclustering-01.svg]]

In the following figures, the "electrons" are left in place but of course their information is not known.  Activity is progressively applied, layer by layer.  After the first layer, no clusters can yet be made as there are no crossing points of strip boundaries.  After two layers, the illustration is as:

[[file:figs/test_rayclustering-03.svg]]

Here, the vertical and horizontal boundary of a the active region of this (fictional) anode plane face is shown as a single square cluster.  The third layer applied is the first actual wire plane and it breaks up the single cluster into three.

[[file:figs/test_rayclustering-04.svg]]

The fourth layer, second wire plane:

[[file:figs/test_rayclustering-05.svg]]

And the final layer:

[[file:figs/test_rayclustering-06.svg]]

And to help guide the eye, this final result overlayed with the original strips.

[[file:figs/test_rayclustering-07.svg]]

* Comments, caveats and todo

This algorithm, as expected, clearly leaves "ghost" clusters as seen above.  These are clusters that do not actually contain any "electrons".  It is the job of subsequent stages to attempt to remove these.  

Finite numerical precision in specifying the ray pairs and calculating their crossing points can lead to slightly larger or smaller clusters.  These can be safely ignored.  However in the MicroBooNE wire pattern case in particular, a ray from each wire plane should exactly cross at a common point.  The lack of precision can thus cause minuscule but noticeable clusters to be formed *around* a triple crossing point. Such clusters are not physical.  Likely a selection based on cluster size can safely remove them.  Besides their small phase space being almost negligible, they form as ghost clusters in the tests that have been performed so far.  In any case, mitigation requires a little study.

Finally, these primitive operations, although central, are implemented as utility code.  To be useful in full scale operation, this code will largely be hidden from view inside WCT components which will handle constructing the coordinates from real wire geometry and filling activity arrays from slice data.

